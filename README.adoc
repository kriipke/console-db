= CONSOLE DB
:version: 0.2.0

== Files

Included in this repo are:

. the diagram of the db used for https://github.com/kriipke/console-api
. an `init.sql` file to create the DB schema using Postgres 14+
. a `types.go` file that creates the golang GORM `structs` needed to use https://gorm.io/index.html[GORM] with the database described in this repo

== Diagram 

Diagram was made using link:https://drawsql.app/teams/techop-1[`drawsql.app`]

https://drawsql.app/teams/techop-1/diagrams/console

image:docs/diagram-v{version}.png[]

== Recommendations from ChatGPT

Let's begin by examining the contents of the init.sql file you've uploaded to understand your database schema. I'll then provide a critique and recommend suggestions based on best practices for database design, especially considering your application's focus on managing multiple Kubernetes clusters across various environments. This will help ensure that your schema is optimized for performance, scalability, and maintainability, which are crucial for managing complex infrastructure environments like Kubernetes/EKS Anywhere.

Let me first take a look at your schema.

The schema you've provided outlines a comprehensive structure designed to manage a Kubernetes/EKS Anywhere environment across multiple clusters and environments (dev, qa, uat, prod). Below is a summary of your schema and some recommendations for improvements:


Security Considerations::
	Password Storage::: The schema includes a password column for users. Ensure that passwords are stored securely using strong, one-way hashing algorithms like bcrypt, Argon2, or similar. Storing plain passwords or weakly hashed passwords can pose a significant security risk.

UUID Primary Keys::
	Indexing and Performance::: Using UUIDs as primary keys is great for distributed systems but can lead to performance issues due to their size and randomness. Ensure your database and queries are optimized for UUID usage, such as by using appropriate indexing strategies.

Foreign Key Constraints::
	Cascade Policies::: Review the ON DELETE policies for foreign keys. For instance, setting some foreign keys to SET NULL on deletion might be appropriate, but in certain cases, especially with critical relational data, you might want ON DELETE CASCADE or ON DELETE RESTRICT to maintain data integrity.

Audit Logs::
	Details Storage::: Consider storing change details in a structured format (e.g., JSONB in PostgreSQL) to facilitate easier querying and analysis. This is mentioned as a comment, but confirming the data type might be useful for your use case.

Schema Versioning::
	Migrations::: As your application evolves, your schema will likely need to change. Plan for schema migration strategies early on, including tools and practices for applying and rolling back schema changes.

Scaling and Performance::
	Indexing::: Besides primary keys, ensure that columns used frequently in WHERE clauses, JOIN conditions, or as part of sorting and grouping operations are indexed to improve query performance.
	Partitioning::: For tables expected to grow significantly (e.g., audit_logs), consider partitioning strategies to maintain performance.

Data Model Adjustments::
	Normalization vs. Denormalization::: Your schema appears well-normalized, which is good for avoiding data duplication and ensuring data integrity. However, for read-heavy environments, consider if there are opportunities for strategic denormalization or caching to improve performance.

Environment-Specific Configurations::
	Ensure there's clear separation and management strategies for configurations that might vary between environments (dev, qa, uat, prod), possibly by leveraging environment-specific tables or naming conventions.

API and Application Integration::
	Since you're using Golang/GORM and gin-gonic, ensure that your model definitions align closely with your database schema to leverage GORM's features effectively, such as automatic migrations, hooks, and CRUD operations.

Documentation and Schema Design Tools::
	Maintain up-to-date documentation of your database schema and consider using schema design tools to visualize and manage relationships and changes over time.
	Your schema is off to a strong start. By considering these recommendations, you can enhance security, maintainability, and performance as your application and database evolve. â€‹

== Usage

=== 1. Enable UUIDs in Postgres

You must run the following SQL command in Postgres before you are able to use the UUID datatype leveraged in this database configuration. 

  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

=== 2. Run the `init.sql` file in a new Postgres container


[source, bash]
----
docker run \
	-v "./init.sql:/docker-entrypoint-initdb.d/init.sql" \ <1>
	-v postgres_data:/var/lib/postgres 
	-p "5432:5432" \
	-d postgres:18-alpine
----
<1> This line initalizes the database with the correct schema.


=== 3. Run the `docker-compose.yml` to start using db

[source, yaml]
----
		version: '3.9'

		services:

			db:
				image: postgres
				restart: always
				# set shared memory limit when using docker-compose
				shm_size: 128mb
				# or set shared memory limit when deploy via swarm stack
				#volumes:
				#  - type: tmpfs
				#    target: /dev/shm
				#    tmpfs:
				#      size: 134217728 # 128*2^20 bytes = 128Mb
				environment:
					POSTGRES_PASSWORD: example

			adminer:
				image: adminer
				restart: always
				ports:
					- 8080:8080
----
